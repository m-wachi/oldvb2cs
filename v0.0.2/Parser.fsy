%{

%}

// The start token becomes a parser function in the compiled code:
%start prog

// Regular tokens
%token HELLO
%token <System.Int32> INT
%token <string> ID
%token EQUAL LPAREN RPAREN
%token LINE_TERM
%token <string> COMMENT
%token <string> STRING

// Misc tokens
%token EOF

// This is the type of the data produced by a successful reduction of the 'start'
// symbol:
%type < Ast.Prog > prog
%type < (Ast.Statement * Ast.Comment) > logical_line
%type < Ast.Statement > statement

%%

// These are the rules of the grammar along with the F# code of the 
// actions executed as rules are reduced.  
prog: 
    logical_lines end { Ast.Prog $1 }
    | end      { Ast.Prog [] }
    

logical_lines:
    logical_line                       { [ $1] }
    | logical_line logical_lines       { $1 :: $2 }

//File:
//	| HELLO						{ Prog [Ast.StringExp "hello"] }
//	| HELLO HELLO				{ Prog [(Ast.StringExp "hello"); (Ast.StringExp "hello")] }
//    | INT                       { Prog [(Ast.IntExp $1)] }
//    | ID INT                    { Prog [(Ast.VarExp (Ast.SimpleVar ($1, 0))); (Ast.IntExp $2)] }
    

logical_line: 
    statement LINE_TERM                  { ($1, "") }
    | statement COMMENT LINE_TERM        { ($1, $2) }
    | COMMENT LINE_TERM                  { (Ast.BlankLine, $1) }
    | LINE_TERM                          { (Ast.BlankLine, "") }
    | subroutine_declaration LINE_TERM   { ($1, "") }

subroutine_declaration:
    SUB ID LPAREN procedure_parameters RPAREN LINE_TERM logical_lines END SUB
        { (Ast.ProcDec {name=(Symbol.symbol ID), params=(procedure_parameters), body=logical_lines, pos=0}) }

procedure_parameters: 
    procedure_parameter   ([procedure_parameter])
    | procedure_parameter COMMA procedure_parameters  (procedure_parameter :: procedure_parameters)
    | ([])
	
procedure_parameter: 
    ID AS vbprimtype ({name=(Symbol.symbol ID), escape=ref false, vbty=(Absyn.VbTySimple (vbprimtype)), pos=0})
    | ID LPAREN RPAREN AS vbprimtype 
        ({name=(Symbol.symbol ID), escape=ref false, vbty=(Absyn.VbTyArray (vbprimtype)), pos=0})


statement:
    ID EQUAL exp               { Ast.AssignStmt (Ast.SimpleVar($1, 0), $3) }

exp: 
    INT                        { Ast.IntExp $1 }
    | STRING                   { Ast.StringExp $1 }

// Using F# keywords for nonterminal names is okay.
end: EOF {}
